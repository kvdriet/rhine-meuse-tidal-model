<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhine-Meuse Tidal Model - Interactive Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Arial, sans-serif; background: #0a0e27; color: #fff; overflow: hidden; }
        #map { width: 100%; height: 100vh; }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            /* Make control panel collapsible and smaller */
            .control-panel {
                max-width: 95vw !important;
                max-height: 40vh !important;
                font-size: 12px;
                padding: 10px !important;
                left: 2.5vw !important;
                top: 10px !important;
                overflow-y: auto;
            }
            
            .control-panel h2 {
                font-size: 16px !important;
                margin-bottom: 10px !important;
                position: sticky;
                top: 0;
                background: rgba(15, 23, 42, 0.97);
                z-index: 10;
                padding: 5px 0;
            }
            
            .control-section {
                padding: 10px !important;
                margin-bottom: 10px !important;
            }
            
            .control-section h3 {
                font-size: 11px !important;
                margin-bottom: 8px !important;
            }
            
            .scenario-buttons {
                grid-template-columns: 1fr 1fr !important;
                gap: 5px !important;
            }
            
            .scenario-btn {
                padding: 8px 4px !important;
                font-size: 11px !important;
            }
            
            .radio-option {
                padding: 6px !important;
                font-size: 11px !important;
            }
            
            .slider-label {
                font-size: 10px !important;
            }
            
            input[type="range"] {
                height: 6px !important;
            }
            
            /* Results panel - move to bottom or make smaller */
            .results-panel {
                max-width: 45vw !important;
                right: 2.5vw !important;
                top: 10px !important;
                font-size: 10px;
                padding: 8px !important;
            }
            
            .results-panel h3 {
                font-size: 12px !important;
                margin-bottom: 6px !important;
            }
            
            .result-item {
                margin-bottom: 4px !important;
            }
            
            /* Animation panel - compact at bottom */
            .animation-panel {
                max-width: 95vw !important;
                bottom: 10px !important;
                left: 2.5vw !important;
                padding: 10px !important;
            }
            
            .animation-panel h3 {
                font-size: 14px !important;
            }
            
            /* Hide legend on mobile to save space */
            .legend {
                display: none !important;
            }
            
            /* Graphs - full screen on mobile */
            .amplitude-graph, #velocityStructure {
                width: 100vw !important;
                max-width: 100vw !important;
                left: 0 !important;
                top: 0 !important;
                padding: 10px !important;
                max-height: 100vh !important;
            }
            
            #amplitudeCanvas, #velocityCanvas {
                max-width: 100%;
                width: 100% !important;
                height: auto !important;
            }
            
            .view-graph-btn, .run-button, .animation-btn {
                font-size: 11px !important;
                padding: 6px 10px !important;
            }
            
            .run-button {
                padding: 10px !important;
                font-size: 13px !important;
            }
            
            /* Time display and controls */
            .time-display {
                font-size: 16px !important;
            }
            
            .animation-controls {
                gap: 8px !important;
            }
            
            /* Make touch targets bigger */
            button, input[type="checkbox"], input[type="radio"] {
                min-height: 36px;
                min-width: 36px;
            }
            
            /* Show toggle button on mobile */
            .panel-toggle {
                display: block !important;
            }
            
            /* Start with panel collapsed on mobile */
            .control-panel {
                transform: translateX(calc(-100% - 20px));
            }
            
            .control-panel:not(.collapsed) {
                transform: translateX(0);
            }
        }
        
        @media (max-width: 480px) {
            .control-panel {
                max-height: 35vh !important;
                font-size: 11px;
            }
            
            .results-panel {
                max-width: 95vw !important;
                right: 2.5vw !important;
                top: auto !important;
                bottom: 180px !important;
            }
            
            .scenario-buttons {
                grid-template-columns: 1fr !important;
            }
        }
        
        .control-panel { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(15, 23, 42, 0.97); 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); 
            z-index: 1000; 
            max-width: 380px; 
            border: 1px solid rgba(56, 189, 248, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        
        .control-panel.collapsed {
            transform: translateX(-100%);
        }
        
        .panel-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.97);
            border: 1px solid rgba(56, 189, 248, 0.3);
            color: #38bdf8;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 999;
            display: none;
            font-size: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }
        
        .panel-toggle:hover {
            background: rgba(56, 189, 248, 0.2);
        }
        
        .control-panel h2 { 
            color: #38bdf8; 
            font-size: 20px; 
            margin-bottom: 15px; 
            border-bottom: 2px solid #38bdf8; 
            padding-bottom: 10px;
        }
        
        .control-section { 
            margin-bottom: 20px; 
            padding: 15px; 
            background: rgba(30, 41, 59, 0.5); 
            border-radius: 8px;
            border-left: 3px solid #38bdf8;
        }
        
        .control-section h3 { 
            color: #38bdf8; 
            font-size: 14px; 
            margin-bottom: 12px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .scenario-buttons { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 8px; 
            margin-top: 10px;
        }
        
        .scenario-btn { 
            background: rgba(56, 189, 248, 0.15); 
            color: #38bdf8; 
            border: 1px solid rgba(56, 189, 248, 0.3); 
            padding: 10px; 
            border-radius: 6px; 
            cursor: pointer; 
            font-weight: 600; 
            font-size: 13px; 
            transition: all 0.3s;
            text-align: center;
        }
        
        .scenario-btn:hover { 
            background: rgba(56, 189, 248, 0.3); 
            transform: translateY(-2px);
        }
        
        .scenario-btn.active { 
            background: #38bdf8; 
            color: #0a0e27;
        }
        
        .radio-group { 
            display: flex; 
            flex-direction: column; 
            gap: 8px;
        }
        
        .radio-option { 
            display: flex; 
            align-items: center; 
            padding: 10px; 
            background: rgba(30, 41, 59, 0.6); 
            border-radius: 6px; 
            cursor: pointer; 
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .radio-option:hover { 
            background: rgba(56, 189, 248, 0.1); 
            border-color: rgba(56, 189, 248, 0.3);
        }
        
        .radio-option.selected { 
            background: rgba(56, 189, 248, 0.2); 
            border-color: #38bdf8;
        }
        
        .radio-option input[type="radio"] { 
            margin-right: 10px; 
            accent-color: #38bdf8;
        }
        
        .slider-container { 
            margin-top: 12px;
        }
        
        .slider-label { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 8px; 
            font-size: 13px; 
            color: #cbd5e1;
        }
        
        .slider-value { 
            color: #38bdf8; 
            font-weight: 600;
        }
        
        input[type="range"] { 
            width: 100%; 
            height: 6px; 
            background: rgba(56, 189, 248, 0.2); 
            border-radius: 3px; 
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb { 
            appearance: none; 
            width: 18px; 
            height: 18px; 
            background: #38bdf8; 
            border-radius: 50%; 
            cursor: pointer;
        }
        
        .run-button { 
            width: 100%; 
            background: linear-gradient(135deg, #38bdf8, #0ea5e9); 
            color: #0a0e27; 
            border: none; 
            padding: 14px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: 700; 
            font-size: 15px; 
            transition: all 0.3s;
            margin-top: 15px;
            text-transform: uppercase;
        }
        
        .run-button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
        }
        
        .run-button.loading {
            background: linear-gradient(135deg, #64748b, #475569);
            cursor: not-allowed;
        }
        
        .results-panel { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            background: rgba(15, 23, 42, 0.97); 
            padding: 20px; 
            border-radius: 12px; 
            z-index: 1000; 
            min-width: 350px;
            border: 1px solid rgba(56, 189, 248, 0.3);
            display: none;
        }
        
        .results-panel.visible { display: block; }
        
        .results-panel h3 { 
            color: #38bdf8; 
            font-size: 16px; 
            margin-bottom: 12px;
        }
        
        .result-item { 
            display: flex; 
            justify-content: space-between; 
            padding: 8px 0; 
            border-bottom: 1px solid rgba(56, 189, 248, 0.2);
            font-size: 13px;
        }
        
        .result-label { color: #cbd5e1; }
        .result-value { 
            color: #38bdf8; 
            font-weight: 600;
        }
        
        .amplitude-graph {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.98);
            padding: 30px;
            border-radius: 12px;
            z-index: 2001;
            border: 2px solid rgba(56, 189, 248, 0.5);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            display: none;
            max-width: 900px;
            max-height: 600px;
        }
        
        .amplitude-graph.visible { display: block; }
        
        .amplitude-graph h3 {
            color: #38bdf8;
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .amplitude-graph canvas {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
        }
        
        .close-graph {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        
        .close-graph:hover {
            background: rgba(239, 68, 68, 1);
        }
        
        .view-graph-btn {
            width: 100%;
            background: rgba(56, 189, 248, 0.2);
            color: #38bdf8;
            border: 1px solid #38bdf8;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.3s;
        }
        
        .view-graph-btn:hover {
            background: rgba(56, 189, 248, 0.3);
        }
        
        .legend { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: rgba(15, 23, 42, 0.97); 
            padding: 15px; 
            border-radius: 10px; 
            z-index: 1000; 
            border: 1px solid rgba(56, 189, 248, 0.3);
        }
        
        .legend h3 { 
            color: #38bdf8; 
            font-size: 14px; 
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .legend-item { 
            display: flex; 
            align-items: center; 
            margin: 6px 0; 
            font-size: 12px;
        }
        
        .legend-color { 
            width: 30px; 
            height: 4px; 
            margin-right: 10px; 
            border-radius: 2px;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(56, 189, 248, 0.2);
            border-top-color: #38bdf8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .leaflet-popup-content-wrapper { 
            background: rgba(15, 23, 42, 0.98); 
            color: #fff; 
            border-radius: 8px; 
            border: 1px solid rgba(56, 189, 248, 0.4);
        }
        .leaflet-popup-content { margin: 10px; font-size: 13px; }
        .leaflet-popup-content h4 { color: #38bdf8; margin-bottom: 8px; }
        .leaflet-popup-tip { background: rgba(15, 23, 42, 0.98); }
        
        /* Animation Controls */
        .animation-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.97);
            padding: 20px;
            border-radius: 12px;
            z-index: 1000;
            min-width: 320px;
            border: 1px solid rgba(56, 189, 248, 0.3);
            display: none;
        }
        
        .animation-panel.visible { display: block; }
        
        .animation-panel h3 {
            color: #38bdf8;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .animation-btn {
            background: rgba(56, 189, 248, 0.15);
            color: #38bdf8;
            border: 1px solid rgba(56, 189, 248, 0.3);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .animation-btn:hover {
            background: rgba(56, 189, 248, 0.3);
        }
        
        .animation-btn.active {
            background: #38bdf8;
            color: #0a0e27;
        }
        
        .time-display {
            text-align: center;
            color: #38bdf8;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .speed-control {
            margin-top: 15px;
        }
        
        .speed-control label {
            color: #cbd5e1;
            font-size: 13px;
            display: block;
            margin-bottom: 8px;
        }
        
        .color-legend {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(56, 189, 248, 0.2);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
    </div>
    
    <div class="control-panel">
        <h2>üåä Tidal Model Explorer</h2>
        
        <div class="control-section">
            <h3>Quick Scenarios</h3>
            <div class="scenario-buttons">
                <button class="scenario-btn" onclick="applyScenario('drought')">üèúÔ∏è Drought</button>
                <button class="scenario-btn active" onclick="applyScenario('baseline')">üìä Baseline</button>
                <button class="scenario-btn" onclick="applyScenario('high_flow')">üåä High Flow</button>
                <button class="scenario-btn" onclick="applyScenario('dredged')">‚öíÔ∏è Dredged</button>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Friction Conditions</h3>
            <div class="radio-group" id="frictionGroup">
                <label class="radio-option">
                    <input type="radio" name="friction" value="very_low">
                    <span>Very Low (Smooth bed)</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="friction" value="low">
                    <span>Low (Clean channel)</span>
                </label>
                <label class="radio-option selected">
                    <input type="radio" name="friction" value="baseline" checked>
                    <span>Baseline (Current)</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="friction" value="high">
                    <span>High (Moderate vegetation)</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="friction" value="very_high">
                    <span>Very High (Dense vegetation)</span>
                </label>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Channel Depth</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>Depth Adjustment</span>
                    <span class="slider-value" id="depthValue">0.0 m</span>
                </div>
                <input type="range" id="depthSlider" min="-2" max="2" step="0.1" value="0">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #64748b; margin-top: 4px;">
                    <span>-2m</span>
                    <span>Baseline</span>
                    <span>+2m</span>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Tidal Boundary Forcing</h3>
            <div class="slider-container">
                <div class="slider-label">
                    <span>M‚ÇÇ Amplitude (North Sea)</span>
                    <span class="slider-value" id="zm2Value">0.80 m</span>
                </div>
                <input type="range" id="zm2Slider" min="0.3" max="1.5" step="0.05" value="0.80">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #64748b; margin-top: 4px;">
                    <span>0.3 m</span>
                    <span>Baseline (0.80 m)</span>
                    <span>1.5 m</span>
                </div>
            </div>
            <div class="slider-container" style="margin-top: 15px;">
                <div class="slider-label">
                    <span>M‚ÇÑ Amplitude (North Sea)</span>
                    <span class="slider-value" id="zm4Value">0.20 m</span>
                </div>
                <input type="range" id="zm4Slider" min="0.0" max="0.5" step="0.02" value="0.20">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #64748b; margin-top: 4px;">
                    <span>0.0 m</span>
                    <span>Baseline (0.20 m)</span>
                    <span>0.5 m</span>
                </div>
            </div>
            <div style="margin-top: 10px; padding: 10px; background: rgba(56, 189, 248, 0.1); border-radius: 6px; font-size: 11px; color: #94a3b8;">
                Controls tidal forcing at ocean boundary. Higher values = stronger tides propagating inland.
            </div>
        </div>
        
        <div class="control-section">
            <h3>Eddy Viscosity</h3>
            <div class="radio-group" id="viscosityGroup">
                <label class="radio-option">
                    <input type="radio" name="viscosity" value="very_low">
                    <span>Very Low</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="viscosity" value="low">
                    <span>Low</span>
                </label>
                <label class="radio-option selected">
                    <input type="radio" name="viscosity" value="baseline" checked>
                    <span>Baseline</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="viscosity" value="high">
                    <span>High</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="viscosity" value="very_high">
                    <span>Very High</span>
                </label>
            </div>
        </div>
        
        <div class="control-section">
            <h3>M‚ÇÑ Tide Source</h3>
            <div class="radio-group" id="m4TypeGroup">
                <label class="radio-option selected">
                    <input type="radio" name="m4_type" value="internal" checked>
                    <span>Internal (Non-linear generation)</span>
                </label>
                <label class="radio-option">
                    <input type="radio" name="m4_type" value="external">
                    <span>External (North Sea boundary)</span>
                </label>
            </div>
            <div style="margin-top: 10px; padding: 10px; background: rgba(56, 189, 248, 0.1); border-radius: 6px; font-size: 11px; color: #94a3b8;">
                <strong style="color: #38bdf8;">Internal:</strong> M‚ÇÑ generated by non-linear processes in the estuary<br>
                <strong style="color: #38bdf8;">External:</strong> M‚ÇÑ from North Sea tidal forcing
            </div>
        </div>
        
        <button class="run-button" onclick="runModel()">‚ö° Run Simulation</button>
    </div>
    
    <div class="results-panel" id="resultsPanel">
        <h3>üìä Simulation Results</h3>
        <div class="result-item">
            <span class="result-label">Max Amplitude:</span>
            <span class="result-value" id="maxAmp">-</span>
        </div>
        <div class="result-item">
            <span class="result-label">Phase Lag:</span>
            <span class="result-value" id="phaseLag">-</span>
        </div>
        <div class="result-item">
            <span class="result-label">Friction Coef:</span>
            <span class="result-value" id="frictionVal">-</span>
        </div>
        <div class="result-item">
            <span class="result-label">Viscosity:</span>
            <span class="result-value" id="viscosityVal">-</span>
        </div>
        <div class="result-item">
            <span class="result-label">M‚ÇÑ Type:</span>
            <span class="result-value" id="m4TypeVal">-</span>
        </div>
        <div class="result-item">
            <span class="result-label">ZM‚ÇÇ / ZM‚ÇÑ:</span>
            <span class="result-value" id="boundaryAmpsVal">-</span>
        </div>
        <button class="view-graph-btn" onclick="showAmplitudeGraph()">üìà View Amplitude Graph</button>
        <button class="view-graph-btn" onclick="showVelocityStructure()" style="margin-top: 10px;">üåÄ View Velocity Structure</button>
    </div>
    
    <div class="amplitude-graph" id="amplitudeGraph">
        <button class="close-graph" onclick="closeAmplitudeGraph()">√ó</button>
        <h3 id="graphTitle">M‚ÇÇ Tidal Amplitude Along Network</h3>
        <div style="display: flex; gap: 10px; margin-bottom: 10px; justify-content: center;">
            <button class="animation-btn" onclick="showGraphComponent('m2')" id="graphM2Btn" style="background: rgba(56, 189, 248, 0.3); padding: 8px 16px;">M‚ÇÇ</button>
            <button class="animation-btn" onclick="showGraphComponent('m4')" id="graphM4Btn" style="padding: 8px 16px;">M‚ÇÑ</button>
            <button class="animation-btn" onclick="showGraphComponent('ratio')" id="graphRatioBtn" style="padding: 8px 16px;">M‚ÇÑ/M‚ÇÇ Ratio</button>
            <button class="animation-btn" onclick="showGraphComponent('asymmetry')" id="graphAsymBtn" style="padding: 8px 16px;">‚ö° Asymmetry</button>
        </div>
        <canvas id="amplitudeCanvas" width="800" height="450"></canvas>
    </div>
    
    <div class="amplitude-graph" id="velocityStructure" style="width: 900px;">
        <button class="close-graph" onclick="closeVelocityStructure()">√ó</button>
        <h3>M‚ÇÇ Velocity Structure (Depth √ó Position)</h3>
        <div style="display: flex; gap: 10px; margin-bottom: 10px; justify-content: center; flex-wrap: wrap;">
            <button class="animation-btn" onclick="showVelocityChannel('nieuwe_waterweg')" id="velNWBtn" style="padding: 6px 12px; font-size: 12px;">Nieuwe Waterweg</button>
            <button class="animation-btn" onclick="showVelocityChannel('hartelkanaal')" id="velHKBtn" style="padding: 6px 12px; font-size: 12px;">Hartelkanaal</button>
            <button class="animation-btn" onclick="showVelocityChannel('nieuwe_maas')" id="velNMBtn" style="padding: 6px 12px; font-size: 12px;">Nieuwe Maas</button>
            <button class="animation-btn" onclick="showVelocityChannel('nieuwe_merwede')" id="velNEBtn" style="padding: 6px 12px; font-size: 12px;">Nieuwe Merwede</button>
            <button class="animation-btn" onclick="showVelocityChannel('oude_maas')" id="velOMBtn" style="padding: 6px 12px; font-size: 12px;">Oude Maas</button>
            <button class="animation-btn" onclick="showVelocityChannel('waal')" id="velWLBtn" style="padding: 6px 12px; font-size: 12px;">Waal</button>
            <button class="animation-btn" onclick="showVelocityChannel('haringvliet')" id="velHVBtn" style="padding: 6px 12px; font-size: 12px;">Haringvliet</button>
        </div>
        <canvas id="velocityCanvas" width="850" height="500"></canvas>
    </div>
    
    <div class="legend">
        <h3>Channels</h3>
        <div class="legend-item"><div class="legend-color" style="background: #d3322f;"></div><span>Waal</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #19d276;"></div><span>Oude Maas</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #173f5f;"></div><span>Nieuwe Maas</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #f6d55c;"></div><span>N. Merwede</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #007cf5;"></div><span>Haringvliet</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #00FFFF;"></div><span>N. Waterweg</span></div>
        <div class="legend-item"><div class="legend-color" style="background: #FF00FF;"></div><span>Hartelkanaal</span></div>
    </div>
    
    <div class="animation-panel" id="animationPanel">
        <h3>üåä Tide Animation</h3>
        <div class="time-display" id="timeDisplay">Time: 0:00</div>
        <div class="animation-controls">
            <button class="animation-btn" id="playBtn" onclick="toggleAnimation()">‚ñ∂Ô∏è Play</button>
            <button class="animation-btn" onclick="resetAnimation()">‚èÆÔ∏è Reset</button>
        </div>
        <div class="speed-control">
            <label>Animation Speed:</label>
            <input type="range" id="speedSlider" min="1" max="30" step="1" value="10" 
                   oninput="updateAnimationSpeed(this.value)">
            <div style="text-align: center; color: #38bdf8; margin-top: 5px;">
                <span id="speedValue">10</span>x
            </div>
        </div>
        <div class="speed-control" style="margin-top: 20px;">
            <label>Tidal Component:</label>
            <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="radio" name="tideComponent" value="m2" checked onchange="switchTidalComponent(this.value)">
                    <span style="font-size: 13px;">M‚ÇÇ (Principal Lunar)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="radio" name="tideComponent" value="m4" onchange="switchTidalComponent(this.value)">
                    <span style="font-size: 13px;">M‚ÇÑ (Overtide)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="radio" name="tideComponent" value="ratio" onchange="switchTidalComponent(this.value)">
                    <span style="font-size: 13px;">M‚ÇÑ/M‚ÇÇ Ratio</span>
                </label>
            </div>
        </div>
        <!-- Velocity vectors removed -->
        <div class="color-legend">
            <label style="color: #cbd5e1; font-size: 13px; margin-bottom: 8px; display: block;" id="colorLegendLabel">M‚ÇÇ Elevation:</label>
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 11px; color: #94a3b8;" id="colorLegendMin">Low Water</span>
                <div id="colorLegendGradient" style="flex: 1; height: 20px; background: linear-gradient(to right, rgb(178,24,43), rgb(255,255,255), rgb(33,102,172)); border-radius: 4px; border: 1px solid rgba(56, 189, 248, 0.3);"></div>
                <span style="font-size: 11px; color: #94a3b8;" id="colorLegendMax">High Water</span>
            </div>
        </div>
    </div>
    
    <!-- Time Series Panel -->
    <div class="graph-panel" id="timeSeriesPanel" style="display: none; position: absolute; top: 20px; right: 400px; width: 700px; background: rgba(15, 23, 42, 0.97); padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); z-index: 999; border: 1px solid rgba(56, 189, 248, 0.3); cursor: move;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="color: #38bdf8; margin: 0; font-size: 16px;" id="timeSeriesTitle">Time Series at Location</h3>
            <button onclick="closeTimeSeries()" style="background: transparent; border: none; color: #38bdf8; font-size: 24px; cursor: pointer; padding: 0; width: 30px; height: 30px;">&times;</button>
        </div>
        <div style="text-align: center; color: #cbd5e1; font-size: 12px; margin-bottom: 10px;" id="timeSeriesInfo"></div>
        <canvas id="timeSeriesCanvas" width="660" height="300"></canvas>
    </div>
    
    <!-- Tooltip overlay -->
    <div id="graphTooltip" style="position: absolute; background: rgba(15, 23, 42, 0.95); color: #fff; padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(56, 189, 248, 0.5); pointer-events: none; display: none; z-index: 10000; font-size: 13px; line-height: 1.6; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // API Configuration
        const API_URL = 'https://rhine-meuse-tidal-model.onrender.com';
        
        var map, channelLayers = [];
        var velocityVectorLayer = null;
        var showVelocityVectors = false;
        var kmlData = {
            nieuwewaterweg: [[51.97316,4.12693],[51.96862,4.13491],[51.96462,4.14227],[51.96080,4.15245],[51.95522,4.16379],[51.94896,4.17568],[51.94373,4.18757],[51.93833,4.20143],[51.93346,4.21331],[51.92788,4.22519],[51.92126,4.23057],[51.91707,4.23509],[51.91306,4.24555],[51.90958,4.25600],[51.90505,4.26673],[51.90157,4.27749],[51.89913,4.28850],[51.89722,4.30009],[51.89426,4.31365],[51.89218,4.32177]],
            hartelkanaal: [[51.93985,4.08370],[51.93901,4.09486],[51.93807,4.10328],[51.93685,4.11273],[51.93545,4.12188],[51.93422,4.13075],[51.93328,4.14144],[51.93206,4.15028],[51.93018,4.15807],[51.92764,4.16585],[51.92529,4.16982],[51.92247,4.17195],[51.91917,4.17623],[51.91531,4.18339],[51.91353,4.18720],[51.91071,4.19315],[51.90760,4.20092],[51.90549,4.20499],[51.90352,4.20862],[51.90187,4.21233],[51.89920,4.21716],[51.89680,4.22019],[51.89473,4.22337],[51.89234,4.22518],[51.88967,4.22751],[51.88579,4.23053],[51.88318,4.23174],[51.87998,4.23329],[51.87753,4.23519],[51.87455,4.23821],[51.87269,4.24184],[51.87120,4.24589],[51.86986,4.25037],[51.86843,4.25443],[51.86720,4.25797],[51.86630,4.26159],[51.86544,4.26694],[51.86539,4.27220],[51.86582,4.27745],[51.86582,4.28228],[51.86598,4.28668],[51.86582,4.29185],[51.86544,4.29755],[51.86544,4.30195],[51.86571,4.30738],[51.86576,4.31144],[51.86566,4.31652],[51.86592,4.32212],[51.86619,4.32834],[51.86618,4.33442]],
            haringvliet: [[51.83471,4.05265],[51.83011,4.06346],[51.82429,4.07745],[51.81762,4.09651],[51.81190,4.11652],[51.80521,4.13839],[51.79717,4.16025],[51.78718,4.18072],[51.77869,4.20159],[51.76518,4.22699],[51.75459,4.24509],[51.73961,4.26397],[51.73079,4.28331],[51.72241,4.30565],[51.71781,4.33924],[51.71634,4.36224],[51.71499,4.38897],[51.71157,4.41551],[51.70667,4.44106],[51.70110,4.46696],[51.69600,4.49849],[51.69425,4.53106],[51.69619,4.55130],[51.70008,4.56841],[51.70486,4.59595],[51.70947,4.60896],[51.71575,4.62143]],
            nieuwemaas: [[51.89209,4.32187],[51.89380,4.32835],[51.89418,4.33520],[51.89674,4.34590],[51.89902,4.35561],[51.89913,4.36522],[51.89750,4.37630],[51.89632,4.38822],[51.89622,4.39768],[51.89855,4.40700],[51.90073,4.41470],[51.90273,4.42625],[51.90159,4.43896],[51.90040,4.45045],[51.89931,4.46131],[51.90101,4.47163],[51.90496,4.48033],[51.91026,4.48776],[51.91477,4.49363],[51.91745,4.50393],[51.91562,4.51219],[51.91209,4.51598],[51.90751,4.51706],[51.90416,4.51786],[51.90078,4.52200],[51.90061,4.53182],[51.90241,4.53584],[51.90522,4.54653],[51.90555,4.55622],[51.90372,4.56747],[51.90394,4.57470],[51.90119,4.58182],[51.89637,4.59176],[51.89373,4.59746],[51.89091,4.61482],[51.88827,4.62068],[51.88378,4.62671],[51.87479,4.63203],[51.86863,4.63756],[51.86425,4.64520],[51.86162,4.64804],[51.85747,4.65371],[51.84987,4.65914],[51.84467,4.66732],[51.83895,4.67445],[51.83397,4.67376],[51.82816,4.67122],[51.82337,4.67065],[51.82025,4.67396],[51.82049,4.68288],[51.82148,4.68902],[51.82262,4.69869],[51.82238,4.70941],[51.82212,4.72051],[51.82229,4.73562],[51.82100,4.75208],[51.81631,4.76278],[51.81394,4.77286],[51.81449,4.78377],[51.81581,4.79493],[51.81744,4.80405],[51.81841,4.81244],[51.81936,4.82489],[51.81740,4.83700],[51.81816,4.85183],[51.81728,4.86890],[51.81798,4.88421]],
            nm: [[51.71568,4.62141],[51.71607,4.63090],[51.71673,4.63873],[51.71857,4.64978],[51.72274,4.66841],[51.72687,4.67884],[51.72957,4.68926],[51.73371,4.69908],[51.73900,4.70914],[51.74442,4.71826],[51.74816,4.72480],[51.75375,4.73244],[51.75906,4.74052],[51.76420,4.74604],[51.77039,4.74908],[51.77525,4.75052],[51.78018,4.75384],[51.78464,4.75940],[51.78875,4.76664],[51.79306,4.77499],[51.79614,4.78467],[51.79871,4.79426],[51.79923,4.80405],[51.79883,4.81565],[51.79783,4.82468],[51.79748,4.83094],[51.79789,4.83942],[51.79897,4.84680],[51.80147,4.85453],[51.80389,4.86221],[51.80738,4.86837],[51.81130,4.87558],[51.81456,4.88049],[51.81625,4.88313],[51.81784,4.88389]],
            oudemaas: [[51.89210,4.32194],[51.89011,4.32261],[51.88798,4.32358],[51.88481,4.32503],[51.88256,4.32599],[51.88036,4.32710],[51.87811,4.32822],[51.87601,4.32916],[51.87261,4.33094],[51.86937,4.33284],[51.86641,4.33423],[51.86543,4.33486],[51.86195,4.33793],[51.85921,4.34032],[51.85679,4.34326],[51.85322,4.34690],[51.85030,4.35107],[51.84858,4.35513],[51.84645,4.36043],[51.84489,4.36584],[51.84367,4.37132],[51.84265,4.37879],[51.84209,4.38462],[51.84207,4.39111],[51.84259,4.39745],[51.84296,4.40263],[51.84301,4.41042],[51.84213,4.41809],[51.84050,4.42365],[51.83889,4.42752],[51.83703,4.43152],[51.83555,4.43635],[51.83279,4.44515],[51.83204,4.45401],[51.83205,4.45951],[51.83254,4.46417],[51.83338,4.47162],[51.83518,4.47896],[51.83573,4.48558],[51.83601,4.49480],[51.83533,4.49922],[51.83406,4.50639],[51.83241,4.51397],[51.83055,4.51978],[51.82998,4.52565],[51.83053,4.53299],[51.83185,4.53856],[51.83234,4.54454],[51.83127,4.55025],[51.82825,4.55552],[51.82414,4.55950],[51.82122,4.56017],[51.81856,4.56180],[51.81510,4.56504],[51.81303,4.56915],[51.81098,4.57363],[51.80878,4.57813],[51.80760,4.58372],[51.80700,4.59014],[51.80619,4.59574],[51.80544,4.60211],[51.80393,4.60903],[51.80201,4.61527],[51.80044,4.61991],[51.79699,4.62285],[51.79214,4.62361],[51.78721,4.62579],[51.78495,4.62777],[51.78095,4.62821],[51.77710,4.62816],[51.77280,4.62711],[51.76855,4.62683],[51.76449,4.62645],[51.76049,4.62721],[51.75496,4.62841],[51.74952,4.63068],[51.74579,4.63123],[51.73807,4.62959],[51.73707,4.62941],[51.73529,4.62896],[51.73256,4.62817],[51.72982,4.62740],[51.72531,4.62500],[51.72154,4.62312],[51.71569,4.62125]],
            waal: [[51.81776,4.88379],[51.82333,4.89993],[51.82547,4.90975],[51.82795,4.92134],[51.82845,4.93123],[51.82768,4.94449],[51.82510,4.95977],[51.82338,4.97491],[51.82147,4.99522],[51.82104,5.01281],[51.81860,5.02884],[51.81764,5.03890],[51.81847,5.05025],[51.82041,5.05911],[51.82381,5.06837],[51.82670,5.08053],[51.82641,5.08814],[51.82597,5.09570],[51.82464,5.10233],[51.82233,5.10822],[51.81900,5.11451],[51.81748,5.12137],[51.81625,5.12654],[51.81453,5.13259],[51.81392,5.14302],[51.81486,5.15129],[51.81513,5.15689],[51.81609,5.16659],[51.81623,5.17366],[51.81530,5.17985],[51.81423,5.18673],[51.81311,5.19079],[51.81136,5.19814],[51.81073,5.20827],[51.81106,5.21754],[51.81196,5.22445],[51.81330,5.23354],[51.81566,5.24081],[51.81781,5.25525],[51.81843,5.26654],[51.82089,5.27815],[51.82253,5.29076],[51.82395,5.29906],[51.82269,5.31233],[51.82062,5.32227],[51.81424,5.33052],[51.81012,5.33680],[51.80477,5.34572],[51.80474,5.35899],[51.80758,5.36863],[51.81495,5.37498],[51.82007,5.37834],[51.82722,5.38407],[51.83190,5.39076],[51.83616,5.39941],[51.84330,5.40950],[51.84821,5.41288],[51.85661,5.41499],[51.86192,5.42105],[51.86929,5.42582],[51.87728,5.43159],[51.88234,5.44530],[51.88744,5.45470],[51.89061,5.47705],[51.89053,5.49270],[51.89014,5.50352],[51.89131,5.51446],[51.89276,5.52464],[51.89516,5.53331],[51.89655,5.53894],[51.89847,5.54929],[51.90095,5.56146],[51.90203,5.57212],[51.90056,5.58423],[51.89985,5.59622],[51.89979,5.60822],[51.89946,5.61854],[51.89989,5.62834],[51.89863,5.63971],[51.89793,5.65048],[51.89638,5.66108],[51.89605,5.67352],[51.89694,5.68279],[51.89632,5.69507],[51.89347,5.70428],[51.89156,5.71245],[51.88720,5.72633],[51.88545,5.74147],[51.88316,5.75342],[51.88057,5.76764],[51.87787,5.78443],[51.87688,5.79639],[51.87429,5.80968],[51.86916,5.81767],[51.86611,5.82735],[51.86309,5.83353],[51.85894,5.83925],[51.85648,5.84543],[51.85336,5.85349],[51.85133,5.86462],[51.85259,5.87479],[51.85547,5.87983],[51.85959,5.88141],[51.86537,5.88772],[51.86966,5.89386],[51.87270,5.90469],[51.87378,5.91443],[51.87500,5.92428],[51.87331,5.93421],[51.86907,5.94129],[51.86539,5.94466],[51.86010,5.95121],[51.85744,5.95538],[51.85486,5.96231],[51.85384,5.96936],[51.85587,5.97582],[51.85908,5.97959],[51.86337,5.98447],[51.86755,5.98797],[51.87305,5.99241],[51.87627,5.99362],[51.87903,5.99830],[51.88068,6.00236],[51.88167,6.01200],[51.88058,6.01895],[51.87705,6.02798],[51.87449,6.03217],[51.87255,6.03656],[51.87207,6.04261],[51.87207,6.05061],[51.86991,6.05647],[51.86552,6.06313]]
        };
        
        function toggleControlPanel() {
            var panel = document.getElementById('controlPanel');
            var toggle = document.getElementById('panelToggle');
            panel.classList.toggle('collapsed');
            toggle.textContent = panel.classList.contains('collapsed') ? '‚ò∞' : '‚úï';
        }
        
        function initMap() {
            if (typeof L === 'undefined') {
                setTimeout(initMap, 200);
                return;
            }
            map = L.map('map').setView([51.88, 4.85], 10);
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri'
            }).addTo(map);
            drawChannels();
        }
        
        function drawChannels() {
            var channels = [
                {name: "Nieuwe Waterweg", color: "#00FFFF", neutralColor: "#94a3b8", weight: 5, coords: kmlData.nieuwewaterweg},
                {name: "Hartelkanaal", color: "#FF00FF", neutralColor: "#94a3b8", weight: 5, coords: kmlData.hartelkanaal},
                {name: "Haringvliet + Hollands Diep", color: "#007cf5", neutralColor: "#94a3b8", weight: 5, coords: kmlData.haringvliet},
                {name: "Nieuwe Maas", color: "#173f5f", neutralColor: "#94a3b8", weight: 5, coords: kmlData.nieuwemaas},
                {name: "Nieuwe Merwede", color: "#f6d55c", neutralColor: "#94a3b8", weight: 5, coords: kmlData.nm},
                {name: "Oude Maas + Dordtsche Kil", color: "#19d276", neutralColor: "#94a3b8", weight: 5, coords: kmlData.oudemaas},
                {name: "Waal", color: "#d3322f", neutralColor: "#94a3b8", weight: 5, coords: kmlData.waal}
            ];
            
            for (var i = 0; i < channels.length; i++) {
                (function() {
                    var ch = channels[i];
                    var line = L.polyline(ch.coords, {
                        color: ch.neutralColor, // Start with neutral gray color
                        weight: ch.weight,
                        opacity: 0.7,
                        smoothFactor: 1
                    }).addTo(map);
                    
                    line.bindPopup('<h4>' + ch.name + '</h4><p>Click to see time series at this channel</p>');
                    
                    // Add click event for time series
                    line.on('click', function(e) {
                        if (!currentResults) {
                            alert('Please run a simulation first!');
                            return;
                        }
                        
                        var channelName = ch.name;
                        var apiName = channelMapping[channelName];
                        
                        console.log('Clicked channel:', channelName, 'API name:', apiName);
                    
                        if (!apiName || !currentResults.channels[apiName]) {
                            alert('Channel data not available for ' + channelName);
                            return;
                        }
                        
                        // Get channel data
                        var channelData = currentResults.channels[apiName];
                        
                        // Find midpoint of channel for time series
                        var midIndex = Math.floor(channelData.length / 2);
                        var midPoint = channelData[midIndex];
                        
                        // Get M4 data if available
                        var m4Point = null;
                        if (currentResults.time_series_m4 && currentResults.time_series_m4.data[apiName]) {
                            var m4Data = currentResults.time_series_m4.data[apiName].points;
                            var m4MidIndex = Math.floor(m4Data.length / 2);
                            m4Point = m4Data[m4MidIndex];
                        }
                        
                        // Prepare data for plotting
                        var m2Data = {
                            amplitude: midPoint.eta.amplitude,
                            phase: midPoint.eta.phase
                        };
                        
                        var m4DataForPlot = null;
                        if (m4Point) {
                            m4DataForPlot = {
                                amplitude: m4Point.amplitude,
                                phase: m4Point.phase
                            };
                        }
                        
                        plotTimeSeries(
                            apiName,
                            channelName,
                            midPoint.position_km || midPoint.position / 1000,
                            m2Data,
                            m4DataForPlot
                        );
                    });
                    
                    channelLayers.push({layer: line, name: ch.name, data: ch});
                })();
            }
        }
        
        // UI Interactions
        document.getElementById('depthSlider').addEventListener('input', function(e) {
            document.getElementById('depthValue').textContent = e.target.value + ' m';
        });
        
        document.getElementById('zm2Slider').addEventListener('input', function(e) {
            document.getElementById('zm2Value').textContent = e.target.value + ' m';
        });
        
        document.getElementById('zm4Slider').addEventListener('input', function(e) {
            document.getElementById('zm4Value').textContent = e.target.value + ' m';
        });
        
        document.querySelectorAll('.radio-option').forEach(function(option) {
            option.addEventListener('click', function() {
                var radio = this.querySelector('input[type="radio"]');
                radio.checked = true;
                this.parentElement.querySelectorAll('.radio-option').forEach(function(opt) {
                    opt.classList.remove('selected');
                });
                this.classList.add('selected');
            });
        });
        
        function applyScenario(scenario) {
            document.querySelectorAll('.scenario-btn').forEach(function(btn) {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            var presets = {
                'drought': {friction: 'high', depth: -1.5, viscosity: 'high'},
                'baseline': {friction: 'baseline', depth: 0, viscosity: 'baseline'},
                'high_flow': {friction: 'low', depth: 1.0, viscosity: 'low'},
                'dredged': {friction: 'very_low', depth: 2.0, viscosity: 'low'}
            };
            
            var preset = presets[scenario];
            document.querySelector('input[name="friction"][value="' + preset.friction + '"]').click();
            document.querySelector('input[name="viscosity"][value="' + preset.viscosity + '"]').click();
            document.getElementById('depthSlider').value = preset.depth;
            document.getElementById('depthValue').textContent = preset.depth + ' m';
        }
        
        async function runModel() {
            var friction = document.querySelector('input[name="friction"]:checked').value;
            var viscosity = document.querySelector('input[name="viscosity"]:checked').value;
            var depth = parseFloat(document.getElementById('depthSlider').value);
            var m4Type = document.querySelector('input[name="m4_type"]:checked').value;
            var zm2 = parseFloat(document.getElementById('zm2Slider').value);
            var zm4 = parseFloat(document.getElementById('zm4Slider').value);
            
            console.log('Running model with M4 type:', m4Type, 'ZM2:', zm2, 'ZM4:', zm4);
            
            var button = document.querySelector('.run-button');
            var overlay = document.getElementById('loadingOverlay');
            
            button.classList.add('loading');
            button.textContent = '‚è≥ Running...';
            overlay.classList.add('active');
            
            try {
                var response = await fetch(API_URL + '/run_model', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        friction_level: friction,
                        depth_adjustment: depth,
                        viscosity_level: viscosity,
                        m4_type: m4Type,
                        zm2_amplitude: zm2,
                        zm4_amplitude: zm4
                    })
                });
                
                if (!response.ok) throw new Error('Model run failed');
                
                var results = await response.json();
                displayResults(results);
                // visualizeOnMap(results); // Don't apply colors immediately - keep neutral gray until animation
                
            } catch (error) {
                console.error('Error:', error);
                alert('Could not connect to model API. The backend might be waking up (takes ~30 seconds on first request). Please try again.');
            } finally {
                button.classList.remove('loading');
                button.textContent = '‚ö° Run Simulation';
                overlay.classList.remove('active');
            }
        }
        
        function displayResults(results) {
            currentResults = results; // Store for graph
            
            // Keep channels neutral gray until animation starts
            restoreChannelLines();
            
            document.getElementById('maxAmp').textContent = results.max_amplitude.toFixed(3) + ' m';
            document.getElementById('phaseLag').textContent = (results.phase_lag * 180 / Math.PI).toFixed(1) + '¬∞';
            document.getElementById('frictionVal').textContent = results.parameters_used.Sf.toFixed(4);
            
            // Display M4 type
            var m4Type = results.parameters_used.m4_type || 'internal';
            var m4TypeLabel = m4Type === 'external' ? 'External (North Sea)' : 'Internal (Non-linear)';
            document.getElementById('m4TypeVal').textContent = m4TypeLabel;
            
            // Display boundary amplitudes
            var zm2 = results.parameters_used.zm2_amplitude || 0.80;
            var zm4 = results.parameters_used.zm4_amplitude || 0.20;
            document.getElementById('boundaryAmpsVal').textContent = zm2.toFixed(2) + ' / ' + zm4.toFixed(2) + ' m';
            
            // Update graph title based on M4 type
            if (document.getElementById('graphM4Btn')) {
                document.getElementById('graphM4Btn').title = m4TypeLabel;
            }
            
            // If graph is open, update its title
            if (currentGraphComponent === 'm4' || currentGraphComponent === 'ratio') {
                showGraphComponent(currentGraphComponent);
            }
            document.getElementById('viscosityVal').textContent = results.parameters_used.Av.toFixed(4);
            document.getElementById('resultsPanel').classList.add('visible');
        }
        
        var channelMapping = {
            'Nieuwe Waterweg': 'nieuwe_waterweg',
            'Hartelkanaal': 'hartelkanaal',
            'Haringvliet + Hollands Diep': 'haringvliet',
            'Nieuwe Maas': 'nieuwe_maas',
            'Nieuwe Merwede': 'nieuwe_merwede',
            'Oude Maas + Dordtsche Kil': 'oude_maas',
            'Waal': 'waal'
        };
        
        // Map display names to kmlData keys
        var kmlMapping = {
            'Nieuwe Waterweg': 'nieuwewaterweg',
            'Hartelkanaal': 'hartelkanaal',
            'Haringvliet + Hollands Diep': 'haringvliet',
            'Nieuwe Maas': 'nieuwemaas',
            'Nieuwe Merwede': 'nm',  // Fixed: was 'nieuwemerwede', but kmlData uses 'nm'
            'Oude Maas + Dordtsche Kil': 'oudemaas',
            'Waal': 'waal'
        };
        
        var currentResults = null; // Store results for graph
        var currentGraphComponent = 'm2'; // 'm2', 'm4', or 'ratio'
        
        function showAmplitudeGraph() {
            if (currentResults) {
                document.getElementById('amplitudeGraph').classList.add('visible');
                plotAmplitudeGraph(currentResults);
            }
        }
        
        function closeAmplitudeGraph() {
            document.getElementById('amplitudeGraph').classList.remove('visible');
        }
        
        var currentVelocityChannel = 'nieuwe_waterweg';
        
        function showVelocityStructure() {
            if (currentResults && currentResults.velocity_structure) {
                document.getElementById('velocityStructure').classList.add('visible');
                showVelocityChannel('nieuwe_waterweg');
            } else {
                alert('Velocity structure data not available. Run simulation first.');
            }
        }
        
        function closeVelocityStructure() {
            document.getElementById('velocityStructure').classList.remove('visible');
        }
        
        function showVelocityChannel(channelKey) {
            currentVelocityChannel = channelKey;
            
            // Update button styles
            ['NW', 'HK', 'NM', 'NE', 'OM', 'WL', 'HV'].forEach(function(btn) {
                var btnEl = document.getElementById('vel' + btn + 'Btn');
                if (btnEl) btnEl.style.background = 'transparent';
            });
            
            var btnMap = {
                'nieuwe_waterweg': 'NW',
                'hartelkanaal': 'HK',
                'nieuwe_maas': 'NM',
                'nieuwe_merwede': 'NE',
                'oude_maas': 'OM',
                'waal': 'WL',
                'haringvliet': 'HV'
            };
            
            var activeBtn = document.getElementById('vel' + btnMap[channelKey] + 'Btn');
            if (activeBtn) activeBtn.style.background = 'rgba(56, 189, 248, 0.3)';
            
            // Plot velocity structure
            if (currentResults) {
                plotVelocityStructure(currentResults, channelKey);
            }
        }
        
        function plotVelocityStructure(results, channelKey) {
            var canvas = document.getElementById('velocityCanvas');
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            var velData = results.velocity_structure;
            if (!velData) {
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '16px Arial';
                ctx.fillText('Velocity structure data not available', width/2 - 150, height/2);
                return;
            }
            
            // Determine which group (ocean, middle, river) and channel index
            var groupData, channelIndex, channelName;
            var channelMap = {
                'nieuwe_waterweg': {group: 'ocean', index: 0, name: 'Nieuwe Waterweg'},
                'hartelkanaal': {group: 'ocean', index: 1, name: 'Hartelkanaal'},
                'nieuwe_maas': {group: 'middle', index: 0, name: 'Nieuwe Maas'},
                'nieuwe_merwede': {group: 'middle', index: 1, name: 'Nieuwe Merwede'},
                'oude_maas': {group: 'middle', index: 2, name: 'Oude Maas'},
                'waal': {group: 'river', index: 0, name: 'Waal'},
                'haringvliet': {group: 'river', index: 1, name: 'Haringvliet'}
            };
            
            var chanInfo = channelMap[channelKey];
            if (!chanInfo) return;
            
            groupData = velData[chanInfo.group];
            if (!groupData || !groupData.u0) {
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '16px Arial';
                ctx.fillText('No velocity data for ' + chanInfo.name, width/2 - 100, height/2);
                return;
            }
            
            // Extract u0[depth, position, channel]
            var u0_3d = groupData.u0;
            var x = groupData.x;
            var z = groupData.z;
            
            console.log('Velocity structure:', {
                u0_exists: !!u0_3d,
                u0_shape: u0_3d ? [u0_3d.length, u0_3d[0] ? u0_3d[0].length : 0, u0_3d[0] && u0_3d[0][0] ? u0_3d[0][0].length : 0] : 'null',
                x_length: x ? x.length : 0,
                z_length: z ? z.length : 0,
                channelIndex: chanInfo.index,
                channelName: chanInfo.name
            });
            
            if (!u0_3d || u0_3d.length === 0) {
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '16px Arial';
                ctx.fillText('Velocity array is empty', width/2 - 100, height/2);
                return;
            }
            
            // Get 2D slice for this channel: u0[:, :, channelIndex]
            var nz = z.length;
            var nx = x.length;  // x is now 1D
            var u_2d = [];
            
            console.log('Extracting velocity slice, nz=' + nz + ', nx=' + nx + ', channel=' + chanInfo.index);
            
            try {
                for (var i = 0; i < nz; i++) {
                    u_2d[i] = [];
                    for (var j = 0; j < nx; j++) {
                        // u0_3d now contains amplitudes directly (not complex numbers)
                        if (!u0_3d[i] || !u0_3d[i][j]) {
                            console.error('Missing data at i=' + i + ', j=' + j);
                            u_2d[i][j] = 0;
                            continue;
                        }
                        var val = u0_3d[i][j][chanInfo.index];
                        if (val === undefined || val === null) {
                            console.error('Undefined velocity at depth=' + i + ', pos=' + j + ', channel=' + chanInfo.index);
                            val = 0;
                        }
                        if (i === 0 && j === 0) {
                            console.log('First velocity value:', val);
                        }
                        u_2d[i][j] = val;
                    }
                }
            } catch (e) {
                console.error('Error extracting velocity:', e);
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '16px Arial';
                ctx.fillText('Error extracting velocity data: ' + e.message, width/2 - 200, height/2);
                return;
            }
            
            console.log('u_2d created, shape:', [u_2d.length, u_2d[0] ? u_2d[0].length : 0]);
            
            // Get x and z coordinates (already 1D from backend)
            var x_coords = x.map(function(v) { return v / 1000; });  // Convert to km
            var z_coords = z;  // Already in meters
            
            // Find min/max for scaling
            var maxU = 0;
            var minX = Math.min.apply(null, x_coords);
            var maxX = Math.max.apply(null, x_coords);
            var minZ = Math.min.apply(null, z_coords);
            var maxZ = Math.max.apply(null, z_coords);
            
            u_2d.forEach(function(row) {
                row.forEach(function(val) {
                    maxU = Math.max(maxU, val);
                });
            });
            
            var padding = {left: 70, right: 150, top: 50, bottom: 60};
            var plotWidth = width - padding.left - padding.right;
            var plotHeight = height - padding.top - padding.bottom;
            
            function scaleX(xval) {
                return padding.left + ((xval - minX) / (maxX - minX)) * plotWidth;
            }
            
            function scaleY(zval) {
                return padding.top + (1 - (zval - minZ) / (maxZ - minZ)) * plotHeight;
            }
            
            // Draw contour filled plot
            var levels = 20;
            for (var i = 0; i < nz - 1; i++) {
                for (var j = 0; j < nx - 1; j++) {
                    var u_avg = (u_2d[i][j] + u_2d[i+1][j] + u_2d[i][j+1] + u_2d[i+1][j+1]) / 4;
                    var normalized = u_avg / maxU;
                    
                    // RdBu_r colormap
                    var color = getRdBuColor_r(normalized);
                    
                    var x1 = scaleX(x_coords[j]);
                    var x2 = scaleX(x_coords[j+1]);
                    var y1 = scaleY(z_coords[i]);
                    var y2 = scaleY(z_coords[i+1]);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x1, y1, x2-x1, y2-y1);
                }
            }
            
            // Draw axes
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#cbd5e1';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Position (km)', width / 2, height - 15);
            
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Depth (m)', 0, 0);
            ctx.restore();
            
            // Title
            ctx.font = 'bold 16px Arial';
            ctx.fillText('M‚ÇÇ Current Amplitude - ' + chanInfo.name, width / 2, 25);
            
            // Colorbar
            var colorbarX = width - padding.right + 20;
            var colorbarY = padding.top;
            var colorbarWidth = 30;
            var colorbarHeight = plotHeight;
            
            // Draw colorbar gradient
            for (var i = 0; i < colorbarHeight; i++) {
                var normalized = 1 - (i / colorbarHeight);
                var color = getRdBuColor_r(normalized);
                ctx.fillStyle = color;
                ctx.fillRect(colorbarX, colorbarY + i, colorbarWidth, 1);
            }
            
            // Colorbar border
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            ctx.strokeRect(colorbarX, colorbarY, colorbarWidth, colorbarHeight);
            
            // Colorbar labels
            ctx.fillStyle = '#cbd5e1';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(maxU.toFixed(3) + ' m/s', colorbarX + colorbarWidth + 5, colorbarY + 10);
            ctx.fillText('0 m/s', colorbarX + colorbarWidth + 5, colorbarY + colorbarHeight - 5);
            
            // Colorbar title
            ctx.save();
            ctx.translate(colorbarX + colorbarWidth + 50, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Current Amplitude (m/s)', 0, 0);
            ctx.restore();
        }
        
        
        function showGraphComponent(component) {
            currentGraphComponent = component;
            
            // Update button styles
            document.getElementById('graphM2Btn').style.background = component === 'm2' ? 'rgba(56, 189, 248, 0.3)' : 'transparent';
            document.getElementById('graphM4Btn').style.background = component === 'm4' ? 'rgba(56, 189, 248, 0.3)' : 'transparent';
            document.getElementById('graphRatioBtn').style.background = component === 'ratio' ? 'rgba(56, 189, 248, 0.3)' : 'transparent';
            document.getElementById('graphAsymBtn').style.background = component === 'asymmetry' ? 'rgba(56, 189, 248, 0.3)' : 'transparent';
            
            // Update title with M4 type indicator
            var title = document.getElementById('graphTitle');
            var m4TypeText = '';
            if (currentResults && currentResults.parameters_used && currentResults.parameters_used.m4_type) {
                m4TypeText = currentResults.parameters_used.m4_type === 'external' ? 
                    ' (External - North Sea)' : ' (Internal - Non-linear)';
            }
            
            if (component === 'm2') {
                title.textContent = 'M‚ÇÇ Tidal Amplitude Along Network';
            } else if (component === 'm4') {
                title.textContent = 'M‚ÇÑ Tidal Amplitude Along Network' + m4TypeText;
            } else if (component === 'ratio') {
                title.textContent = 'M‚ÇÑ/M‚ÇÇ Ratio Along Network' + m4TypeText;
            } else if (component === 'asymmetry') {
                title.textContent = 'Tidal Asymmetry (Skewness) Along Network' + m4TypeText;
            }
            
            // Replot with new component
            if (currentResults) {
                plotAmplitudeGraph(currentResults);
            }
        }
        
        function plotAmplitudeGraph(results) {
            console.log('plotAmplitudeGraph called with component:', currentGraphComponent);
            if (currentGraphComponent === 'asymmetry') {
                console.log('Asymmetry data available:', !!results.asymmetry);
                if (results.asymmetry) {
                    console.log('Asymmetry data keys:', Object.keys(results.asymmetry.data));
                }
            }
            
            var canvas = document.getElementById('amplitudeCanvas');
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Define channels to plot with colors (matching legend)
            var channelsToPlot = [
                {key: 'nieuwe_waterweg', name: 'NW', color: '#00FFFF'},
                {key: 'hartelkanaal', name: 'HK', color: '#FF00FF'},
                {key: 'nieuwe_maas', name: 'NM', color: '#0000FF'},
                {key: 'nieuwe_merwede', name: 'NE', color: '#FF0000'},
                {key: 'oude_maas', name: 'OM', color: '#000000'},
                {key: 'waal', name: 'WL', color: '#FFA500'},
                {key: 'haringvliet', name: 'HV', color: '#008000'}
            ];
            
            // Helper function to get data based on current component
            function getAmplitudeData(channelKey) {
                if (currentGraphComponent === 'm2') {
                    return results.channels[channelKey];
                } else if (currentGraphComponent === 'm4' && results.time_series_m4) {
                    var m4Data = results.time_series_m4.data[channelKey];
                    if (!m4Data) return null;
                    
                    // M4 data now has position information directly
                    return m4Data.points.map(function(pt) {
                        return {
                            position_km: pt.position_km,
                            position: pt.position,
                            eta: { amplitude: pt.amplitude }
                        };
                    });
                } else if (currentGraphComponent === 'ratio' && results.m4_m2_ratio) {
                    var ratioData = results.m4_m2_ratio.data[channelKey];
                    if (!ratioData) return null;
                    
                    // Ratio data now has position information directly
                    return ratioData.points.map(function(pt) {
                        return {
                            position_km: pt.position_km,
                            position: pt.position,
                            eta: { amplitude: pt.ratio }
                        };
                    });
                } else if (currentGraphComponent === 'asymmetry' && results.asymmetry) {
                    console.log('Getting asymmetry data for channel:', channelKey);
                    var asymData = results.asymmetry.data[channelKey];
                    if (!asymData) {
                        console.log('No asymmetry data for channel:', channelKey);
                        return null;
                    }
                    
                    console.log('Asymmetry points for', channelKey, ':', asymData.points.length);
                    if (asymData.points.length > 0) {
                        console.log('First asymmetry point:', asymData.points[0]);
                    }
                    
                    // Asymmetry data with skewness
                    return asymData.points.map(function(pt) {
                        return {
                            position_km: pt.position_km,
                            position: pt.position,
                            eta: { amplitude: pt.skewness },
                            horiz_asymmetry: pt.horiz_asymmetry,
                            phase_difference: pt.phase_difference
                        };
                    });
                }
                return null;
            }
            
            // Find max amplitude and position range
            var maxAmp = 0;
            var minPos = Infinity;
            var maxPos = -Infinity;
            
            channelsToPlot.forEach(function(ch) {
                var data = getAmplitudeData(ch.key);
                if (data) {
                    data.forEach(function(pt) {
                        var ampVal = Math.abs(pt.eta.amplitude);
                        maxAmp = Math.max(maxAmp, ampVal);
                        var pos = pt.position_km || pt.position / 1000;
                        minPos = Math.min(minPos, pos);
                        maxPos = Math.max(maxPos, pos);
                    });
                }
            });
            
            // For asymmetry, handle negative values properly
            if (currentGraphComponent === 'asymmetry') {
                var minAmp = 0;
                channelsToPlot.forEach(function(ch) {
                    var data = getAmplitudeData(ch.key);
                    if (data) {
                        data.forEach(function(pt) {
                            minAmp = Math.min(minAmp, pt.eta.amplitude);
                        });
                    }
                });
                console.log('Asymmetry range:', minAmp, 'to', maxAmp);
            }
            
            // Add padding to x-range (especially on left for negative values)
            var xRange = maxPos - minPos;
            minPos = minPos - xRange * 0.1;  // 10% padding on left
            maxPos = maxPos + xRange * 0.05;  // 5% padding on right
            
            var padding = {left: 60, right: 150, top: 40, bottom: 50};
            var plotWidth = width - padding.left - padding.right;
            var plotHeight = height - padding.top - padding.bottom;
            
            // Scale functions
            function scaleX(pos) {
                return padding.left + ((pos - minPos) / (maxPos - minPos)) * plotWidth;
            }
            
            function scaleY(amp) {
                if (currentGraphComponent === 'asymmetry') {
                    // Handle negative values for asymmetry
                    var minAmp = 0;
                    channelsToPlot.forEach(function(ch) {
                        var data = getAmplitudeData(ch.key);
                        if (data) {
                            data.forEach(function(pt) {
                                minAmp = Math.min(minAmp, pt.eta.amplitude);
                            });
                        }
                    });
                    var range = maxAmp - minAmp;
                    return height - padding.bottom - ((amp - minAmp) / range) * plotHeight;
                } else {
                    return height - padding.bottom - (amp / (maxAmp * 1.05)) * plotHeight;  // Less padding on top
                }
            }
            
            // Draw axes
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(padding.left, padding.top);
            ctx.stroke();
            
            // Draw grid and axes
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            for (var i = 0; i <= 5; i++) {
                var y = height - padding.bottom - (i / 5) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                // Y-axis labels
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                
                if (currentGraphComponent === 'asymmetry') {
                    // Calculate min for asymmetry
                    var minAmp = 0;
                    channelsToPlot.forEach(function(ch) {
                        var data = getAmplitudeData(ch.key);
                        if (data) {
                            data.forEach(function(pt) {
                                minAmp = Math.min(minAmp, pt.eta.amplitude);
                            });
                        }
                    });
                    var range = maxAmp - minAmp;
                    var labelValue = minAmp + (i / 5) * range;
                    ctx.fillText(labelValue.toFixed(3), padding.left - 5, y + 4);
                } else {
                    ctx.fillText((maxAmp * i / 5 * 1.05).toFixed(2), padding.left - 5, y + 4);
                }
            }
            
            // X-axis grid and labels
            var xTicks = 8;
            for (var i = 0; i <= xTicks; i++) {
                var x = padding.left + (i / xTicks) * plotWidth;
                var xValue = minPos + (i / xTicks) * (maxPos - minPos);
                
                // Grid line
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, height - padding.bottom);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(xValue.toFixed(0), x, height - padding.bottom + 20);
            }
            
            // Draw zero line for asymmetry plot
            if (currentGraphComponent === 'asymmetry') {
                var zeroY = scaleY(0);
                ctx.strokeStyle = '#f59e0b';  // Orange color for zero line
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(padding.left, zeroY);
                ctx.lineTo(width - padding.right, zeroY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label zero line
                ctx.fillStyle = '#f59e0b';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Zero (balanced)', padding.left + 5, zeroY - 5);
            }
            
            // Axis labels
            ctx.fillStyle = '#cbd5e1';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Position (km)', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            var yLabel = currentGraphComponent === 'm2' ? 'M‚ÇÇ elevation amplitude (m)' : 
                        currentGraphComponent === 'm4' ? 'M‚ÇÑ elevation amplitude (m)' :
                        currentGraphComponent === 'ratio' ? 'M‚ÇÑ/M‚ÇÇ ratio' :
                        'Skewness (>0: flood, <0: ebb)';
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
            
            // Plot each channel
            channelsToPlot.forEach(function(ch) {
                var data = getAmplitudeData(ch.key);
                if (data) {
                    ctx.strokeStyle = ch.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    
                    var started = false;
                    data.forEach(function(pt) {
                        var x = scaleX(pt.position_km || pt.position / 1000);
                        var y = scaleY(pt.eta.amplitude);
                        
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                }
            });
            
            // Draw legend
            var legendX = width - padding.right + 20;
            var legendY = padding.top;
            
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#cbd5e1';
            ctx.textAlign = 'left';
            
            channelsToPlot.forEach(function(ch, i) {
                var y = legendY + i * 20;
                
                // Line
                ctx.strokeStyle = ch.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(legendX, y);
                ctx.lineTo(legendX + 30, y);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#cbd5e1';
                ctx.fillText(ch.name, legendX + 35, y + 4);
            });
            
            // Setup tooltip event listeners after plotting
            setupGraphTooltip(channelsToPlot, getAmplitudeData, scaleX, scaleY, padding, minPos, maxPos, maxAmp);
        }
        
        function setupGraphTooltip(channelsToPlot, getAmplitudeData, scaleX, scaleY, padding, minPos, maxPos, maxAmp) {
            var canvas = document.getElementById('amplitudeCanvas');
            var tooltip = document.getElementById('graphTooltip');
            
            // Store current data for lookups
            var channelDataCache = {};
            channelsToPlot.forEach(function(ch) {
                channelDataCache[ch.key] = getAmplitudeData(ch.key);
            });
            
            canvas.onmousemove = function(e) {
                var rect = canvas.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;
                
                // Check if mouse is within plot area
                if (mouseX < padding.left || mouseX > canvas.width - padding.right ||
                    mouseY < padding.top || mouseY > canvas.height - padding.bottom) {
                    tooltip.style.display = 'none';
                    return;
                }
                
                // Find closest point
                var closestPoint = null;
                var closestDist = Infinity;
                var closestChannel = null;
                
                channelsToPlot.forEach(function(ch) {
                    var data = channelDataCache[ch.key];
                    if (data) {
                        data.forEach(function(pt) {
                            var x = scaleX(pt.position_km || pt.position / 1000);
                            var y = scaleY(pt.eta.amplitude);
                            var dist = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                            
                            if (dist < closestDist && dist < 20) {  // 20px threshold
                                closestDist = dist;
                                closestPoint = pt;
                                closestChannel = ch;
                            }
                        });
                    }
                });
                
                if (closestPoint && closestChannel) {
                    // Build tooltip content
                    var channelNames = {
                        'nieuwe_waterweg': 'Nieuwe Waterweg',
                        'hartelkanaal': 'Hartelkanaal',
                        'nieuwe_maas': 'Nieuwe Maas',
                        'nieuwe_merwede': 'Nieuwe Merwede',
                        'oude_maas': 'Oude Maas',
                        'waal': 'Waal',
                        'haringvliet': 'Haringvliet'
                    };
                    
                    var html = '<div style="font-weight: bold; color: ' + closestChannel.color + ';">' + 
                               channelNames[closestChannel.key] + '</div>';
                    html += '<div>Position: ' + (closestPoint.position_km || closestPoint.position / 1000).toFixed(2) + ' km</div>';
                    html += '<div>Amplitude: ' + closestPoint.eta.amplitude.toFixed(4) + ' m</div>';
                    
                    // Add phase if available (M2 data)
                    if (closestPoint.eta.phase !== undefined && currentGraphComponent === 'm2') {
                        html += '<div>Phase: ' + closestPoint.eta.phase.toFixed(3) + ' rad</div>';
                    }
                    
                    // Add ratio info if applicable
                    if (currentGraphComponent === 'ratio') {
                        html += '<div style="margin-top: 5px; padding-top: 5px; border-top: 1px solid rgba(56, 189, 248, 0.3);">';
                        html += 'Ratio = M‚ÇÑ/M‚ÇÇ: ' + (closestPoint.eta.amplitude * 100).toFixed(2) + '%</div>';
                    }
                    
                    // Add asymmetry info if applicable
                    if (currentGraphComponent === 'asymmetry') {
                        html += '<div style="margin-top: 5px; padding-top: 5px; border-top: 1px solid rgba(56, 189, 248, 0.3);">';
                        html += 'Skewness: ' + closestPoint.eta.amplitude.toFixed(3);
                        html += '<br>' + (closestPoint.eta.amplitude > 0 ? '‚ñ≤ Flood dominant' : '‚ñº Ebb dominant');
                        if (closestPoint.horiz_asymmetry !== undefined) {
                            html += '<br>H. Asym: ' + closestPoint.horiz_asymmetry.toFixed(3);
                        }
                        html += '</div>';
                    }
                    
                    tooltip.innerHTML = html;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            };
            
            canvas.onmouseleave = function() {
                tooltip.style.display = 'none';
            };
            
            // Add click handler for time series
            canvas.onclick = function(e) {
                var rect = canvas.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;
                
                // Check if mouse is within plot area
                if (mouseX < padding.left || mouseX > canvas.width - padding.right ||
                    mouseY < padding.top || mouseY > canvas.height - padding.bottom) {
                    return;
                }
                
                // Find closest point
                var closestPoint = null;
                var closestDist = Infinity;
                var closestChannel = null;
                
                channelsToPlot.forEach(function(ch) {
                    var data = channelDataCache[ch.key];
                    if (data) {
                        data.forEach(function(pt) {
                            var x = scaleX(pt.position_km || pt.position / 1000);
                            var y = scaleY(pt.eta.amplitude);
                            var dist = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                            
                            if (dist < closestDist && dist < 20) {
                                closestDist = dist;
                                closestPoint = pt;
                                closestChannel = ch;
                            }
                        });
                    }
                });
                
                if (closestPoint && closestChannel && currentResults) {
                    // Get M2 and M4 data for this point
                    var channelNames = {
                        'nieuwe_waterweg': 'Nieuwe Waterweg',
                        'hartelkanaal': 'Hartelkanaal',
                        'nieuwe_maas': 'Nieuwe Maas',
                        'nieuwe_merwede': 'Nieuwe Merwede',
                        'oude_maas': 'Oude Maas',
                        'waal': 'Waal',
                        'haringvliet': 'Haringvliet'
                    };
                    
                    // Get full channel data from results
                    var m2ChannelData = currentResults.channels[closestChannel.key];
                    
                    // Find the exact point in full data
                    var m2Point = null;
                    var minDist = Infinity;
                    m2ChannelData.forEach(function(pt) {
                        var dist = Math.abs((pt.position_km || pt.position / 1000) - (closestPoint.position_km || closestPoint.position / 1000));
                        if (dist < minDist) {
                            minDist = dist;
                            m2Point = pt;
                        }
                    });
                    
                    // Get M4 data for this channel and position
                    var m4Point = null;
                    if (currentResults.time_series_m4 && currentResults.time_series_m4.data[closestChannel.key]) {
                        var m4Data = currentResults.time_series_m4.data[closestChannel.key].points;
                        var minDist = Infinity;
                        m4Data.forEach(function(pt) {
                            var dist = Math.abs(pt.position_km - (closestPoint.position_km || closestPoint.position / 1000));
                            if (dist < minDist) {
                                minDist = dist;
                                m4Point = pt;
                            }
                        });
                    }
                    
                    // Prepare data for plotting
                    var m2Data = {
                        amplitude: m2Point.eta.amplitude,
                        phase: m2Point.eta.phase
                    };
                    
                    var m4Data = null;
                    if (m4Point) {
                        m4Data = {
                            amplitude: m4Point.amplitude,
                            phase: m4Point.phase
                        };
                    }
                    
                    plotTimeSeries(
                        closestChannel.key,
                        channelNames[closestChannel.key],
                        closestPoint.position_km || closestPoint.position / 1000,
                        m2Data,
                        m4Data
                    );
                }
            };
        }
        
        var isDragging = false;
        var dragOffsetX = 0;
        var dragOffsetY = 0;
        
        function initDraggablePanel() {
            var panel = document.getElementById('timeSeriesPanel');
            var header = panel.querySelector('h3').parentElement;
            
            header.style.cursor = 'move';
            
            header.onmousedown = function(e) {
                isDragging = true;
                var rect = panel.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                panel.style.cursor = 'grabbing';
                header.style.cursor = 'grabbing';
            };
            
            document.onmousemove = function(e) {
                if (isDragging) {
                    var panel = document.getElementById('timeSeriesPanel');
                    var newLeft = e.clientX - dragOffsetX;
                    var newTop = e.clientY - dragOffsetY;
                    
                    // Keep within window bounds
                    newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panel.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, window.innerHeight - panel.offsetHeight));
                    
                    panel.style.left = newLeft + 'px';
                    panel.style.top = newTop + 'px';
                    panel.style.right = 'auto';
                    panel.style.bottom = 'auto';
                }
            };
            
            document.onmouseup = function() {
                if (isDragging) {
                    isDragging = false;
                    var panel = document.getElementById('timeSeriesPanel');
                    panel.style.cursor = 'move';
                    header.style.cursor = 'move';
                }
            };
        }
        
        function closeTimeSeries() {
            document.getElementById('timeSeriesPanel').style.display = 'none';
        }
        
        // Version 2.0 - Velocity vectors fixed
        function toggleVelocityVectors(show) {
            showVelocityVectors = show;
            console.log('Velocity vectors toggled:', show);
            if (!show) {
                // Remove vectors when disabled
                if (velocityVectorLayer) {
                    map.removeLayer(velocityVectorLayer);
                    velocityVectorLayer = null;
                }
            }
            // Vectors will be drawn during next animation frame if enabled
        }
        
        function plotTimeSeries(channelKey, channelName, positionKm, m2Data, m4Data) {
            var panel = document.getElementById('timeSeriesPanel');
            var canvas = document.getElementById('timeSeriesCanvas');
            var ctx = canvas.getContext('2d');
            var width = canvas.width;
            var height = canvas.height;
            
            // Clear canvas completely
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'rgba(15, 23, 42, 1)';
            ctx.fillRect(0, 0, width, height);
            
            // Show panel and initialize dragging if first time
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                initDraggablePanel();
            } else {
                panel.style.display = 'block';
            }
            
            // Update title and info
            document.getElementById('timeSeriesTitle').textContent = 'Time Series at ' + channelName;
            document.getElementById('timeSeriesInfo').textContent = 'Position: ' + positionKm.toFixed(2) + ' km | Click graph to close or select another location';
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Generate time series data
            var numPoints = 200;
            var periodM2 = 12.42; // hours
            var periodM4 = periodM2 / 2; // M4 is half period of M2
            var omega2 = 2 * Math.PI / (periodM2 * 3600); // rad/s
            var omega4 = 2 * omega2; // M4 frequency is twice M2
            
            var timeData = [];
            var etaM2 = [];
            var etaM4 = [];
            var etaTotal = [];
            
            for (var i = 0; i < numPoints; i++) {
                var t = (i / numPoints) * periodM2 * 3600; // time in seconds
                var tHours = t / 3600; // time in hours
                timeData.push(tHours);
                
                // Calculate M2 component: eta = amplitude * cos(omega*t - phase)
                var m2Val = m2Data.amplitude * Math.cos(omega2 * t - m2Data.phase);
                etaM2.push(m2Val);
                
                // Calculate M4 component if available
                var m4Val = 0;
                if (m4Data && m4Data.amplitude) {
                    m4Val = m4Data.amplitude * Math.cos(omega4 * t - m4Data.phase);
                    etaM4.push(m4Val);
                }
                
                // Total tide
                etaTotal.push(m2Val + m4Val);
            }
            
            // Find min/max for scaling
            var maxEta = Math.max(Math.max.apply(null, etaTotal), Math.max.apply(null, etaM2));
            var minEta = Math.min(Math.min.apply(null, etaTotal), Math.min.apply(null, etaM2));
            var etaRange = maxEta - minEta;
            
            var padding = {left: 60, right: 30, top: 40, bottom: 50};
            var plotWidth = width - padding.left - padding.right;
            var plotHeight = height - padding.top - padding.bottom;
            
            // Scale functions
            function scaleX(hours) {
                return padding.left + (hours / periodM2) * plotWidth;
            }
            
            function scaleY(eta) {
                return padding.top + plotHeight - ((eta - minEta) / etaRange) * plotHeight;
            }
            
            // Draw axes
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // Draw grid
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines
            for (var i = 0; i <= 5; i++) {
                var y = padding.top + (i / 5) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                // Y-axis labels
                var etaVal = maxEta - (i / 5) * etaRange;
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(etaVal.toFixed(2), padding.left - 5, y + 4);
            }
            
            // Vertical grid lines (every 2 hours)
            for (var i = 0; i <= 6; i++) {
                var hours = i * 2;
                var x = scaleX(hours);
                ctx.strokeStyle = '#334155';
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, height - padding.bottom);
                ctx.stroke();
                
                // X-axis labels
                ctx.fillStyle = '#cbd5e1';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(hours.toFixed(0) + 'h', x, height - padding.bottom + 20);
            }
            
            // Axis labels
            ctx.fillStyle = '#cbd5e1';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time (hours)', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Water Level (m)', 0, 0);
            ctx.restore();
            
            // Plot M2 component (dashed blue line)
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (var i = 0; i < numPoints; i++) {
                var x = scaleX(timeData[i]);
                var y = scaleY(etaM2[i]);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Plot M4 component if available (dashed orange line)
            if (m4Data && m4Data.amplitude > 0) {
                ctx.strokeStyle = '#fb923c';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                for (var i = 0; i < numPoints; i++) {
                    var x = scaleX(timeData[i]);
                    var y = scaleY(etaM4[i]);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Plot total tide (solid cyan line)
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (var i = 0; i < numPoints; i++) {
                var x = scaleX(timeData[i]);
                var y = scaleY(etaTotal[i]);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Draw legend
            var legendX = width - padding.right - 180;
            var legendY = padding.top + 10;
            
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            
            // Total
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 30, legendY);
            ctx.stroke();
            ctx.fillStyle = '#cbd5e1';
            ctx.fillText('M‚ÇÇ + M‚ÇÑ', legendX + 35, legendY + 4);
            
            // M2
            legendY += 20;
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 30, legendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#cbd5e1';
            ctx.fillText('M‚ÇÇ only', legendX + 35, legendY + 4);
            
            // M4 if available
            if (m4Data && m4Data.amplitude > 0) {
                legendY += 20;
                ctx.strokeStyle = '#fb923c';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(legendX, legendY);
                ctx.lineTo(legendX + 30, legendY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#cbd5e1';
                ctx.fillText('M‚ÇÑ only', legendX + 35, legendY + 4);
            }
        }
        
        function visualizeOnMap(results) {
            channelLayers.forEach(function(ch) {
                var apiName = channelMapping[ch.name];
                
                if (apiName && results.channels[apiName]) {
                    var channelData = results.channels[apiName];
                    
                    // Calculate statistics
                    var avgAmplitude = channelData.reduce(function(sum, pt) {
                        return sum + pt.eta.amplitude;
                    }, 0) / channelData.length;
                    
                    var maxAmp = Math.max.apply(Math, channelData.map(function(pt) { return pt.eta.amplitude; }));
                    var minAmp = Math.min.apply(Math, channelData.map(function(pt) { return pt.eta.amplitude; }));
                    
                    // Update line weight based on average amplitude
                    var newWeight = 4 + (avgAmplitude * 10);
                    
                    // Color intensity based on amplitude (brighter = higher amplitude)
                    var originalColor = ch.data.color;
                    var opacity = 0.6 + (avgAmplitude * 0.4); // 0.6 to 1.0
                    
                    ch.layer.setStyle({
                        weight: newWeight, 
                        opacity: opacity,
                        color: originalColor
                    });
                    
                    // Determine channel type
                    var channelType = 'Unknown';
                    if (apiName === 'waal') {
                        channelType = 'River';
                    } else if (apiName === 'haringvliet') {
                        channelType = 'River-like (Closed)';
                    } else if (apiName.includes('maas') || apiName === 'nieuwe_merwede') {
                        channelType = 'Middle';
                    } else {
                        channelType = 'Ocean';
                    }
                    
                    // Create amplitude profile visualization hint
                    var amplitudeGradient = '';
                    if (channelData.length > 2) {
                        var firstAmp = channelData[0].eta.amplitude;
                        var lastAmp = channelData[channelData.length - 1].eta.amplitude;
                        if (Math.abs(lastAmp - firstAmp) > 0.05) {
                            amplitudeGradient = firstAmp > lastAmp ? 'üìâ Dampening' : 'üìà Amplifying';
                        }
                    }
                    
                    // Update popup with detailed results
                    var popupContent = '<h4>' + ch.name + '</h4>' +
                        '<p><strong>Type:</strong> ' + channelType + '</p>' +
                        '<p><strong>Avg Amplitude:</strong> ' + avgAmplitude.toFixed(3) + ' m</p>' +
                        '<p><strong>Tidal Range:</strong> ' + (avgAmplitude * 2).toFixed(3) + ' m</p>' +
                        '<p><strong>Max:</strong> ' + maxAmp.toFixed(3) + ' m | <strong>Min:</strong> ' + minAmp.toFixed(3) + ' m</p>' +
                        (amplitudeGradient ? '<p>' + amplitudeGradient + '</p>' : '') +
                        (apiName === 'haringvliet' ? '<p style="font-size: 11px; color: #94a3b8; margin-top: 8px;">‚ö†Ô∏è Closed channel: strong tide dampening</p>' : '');
                    
                    ch.layer.setPopupContent(popupContent);
                    
                    // Add tooltip on hover
                    ch.layer.bindTooltip(ch.name + ': ' + avgAmplitude.toFixed(3) + ' m', {
                        permanent: false,
                        direction: 'top'
                    });
                }
            });
            
            console.log('Visualization complete! Line thickness and opacity show tidal amplitude.');
        }
        
        // ===== ANIMATION FUNCTIONS =====
        
        // Animation state
        var animationData = null;
        var animationData_m4 = null;
        var animationData_ratio = null;
        var currentTidalComponent = 'm2'; // 'm2', 'm4', or 'ratio'
        var animationInterval = null;
        var currentFrame = 0;
        var animationSpeed = 10; // frames per second (default 10 FPS)
        var isPlaying = false;
        var scatterMarkers = []; // Store scatter point markers for animation

        function toggleAnimation() {
            if (!animationData) {
                alert('Please run a simulation first!');
                return;
            }
            
            if (isPlaying) {
                pauseAnimation();
            } else {
                playAnimation();
            }
        }

        function playAnimation() {
            isPlaying = true;
            document.getElementById('playBtn').innerHTML = '‚è∏Ô∏è Pause';
            document.getElementById('playBtn').classList.add('active');
            
            animationInterval = setInterval(function() {
                currentFrame = (currentFrame + 1) % animationData.num_frames;
                updateVisualization(currentFrame);
            }, 1000 / animationSpeed);
        }

        function pauseAnimation() {
            isPlaying = false;
            document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Play';
            document.getElementById('playBtn').classList.remove('active');
            
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            // Restore original channel lines when paused
            restoreChannelLines();
            
            // Remove scatter markers
            scatterMarkers.forEach(function(marker) {
                map.removeLayer(marker);
            });
            scatterMarkers = [];
        }

        function resetAnimation() {
            pauseAnimation();
            currentFrame = 0;
        }
        
        // Switch between M2, M4, and M4/M2 ratio
        function switchTidalComponent(component) {
            var wasPlaying = isPlaying;
            if (wasPlaying) pauseAnimation();
            
            currentTidalComponent = component;
            currentFrame = 0;
            
            // Update color legend
            var label = document.getElementById('colorLegendLabel');
            var minLabel = document.getElementById('colorLegendMin');
            var maxLabel = document.getElementById('colorLegendMax');
            var gradient = document.getElementById('colorLegendGradient');
            
            if (component === 'm2') {
                label.textContent = 'M‚ÇÇ Elevation:';
                minLabel.textContent = 'Low';
                maxLabel.textContent = 'High';
                gradient.style.background = 'linear-gradient(to right, rgb(33,102,172), rgb(255,255,255), rgb(178,24,43))';
            } else if (component === 'm4') {
                label.textContent = 'M‚ÇÑ Elevation:';
                minLabel.textContent = 'Low';
                maxLabel.textContent = 'High';
                gradient.style.background = 'linear-gradient(to right, rgb(33,102,172), rgb(255,255,255), rgb(178,24,43))';
            } else if (component === 'ratio') {
                label.textContent = 'M‚ÇÑ/M‚ÇÇ Ratio:';
                minLabel.textContent = '0';
                maxLabel.textContent = 'Max';
                gradient.style.background = 'linear-gradient(to right, rgb(255,255,255), rgb(255,200,0), rgb(178,24,43))';
            }
            
            // Update visualization to show new component
            updateVisualization(currentFrame);
            
            if (wasPlaying) playAnimation();
        }
        
        // Restore original channel line visibility
        function restoreChannelLines() {
            channelLayers.forEach(function(ch) {
                ch.layer.setStyle({
                    color: ch.data.neutralColor || '#94a3b8', // Use neutral gray
                    weight: ch.data.weight,
                    opacity: 0.7,
                    fillOpacity: 0
                });
            });
        }

        function updateAnimationSpeed(value) {
            animationSpeed = parseFloat(value);
            document.getElementById('speedValue').textContent = (value / 10).toFixed(0); // Display as 1x, 2x, etc
            
            // Restart animation if playing
            if (isPlaying) {
                pauseAnimation();
                playAnimation();
            }
        }

        function drawVelocityVectors(frameIndex) {
            console.log('drawVelocityVectors called, frame:', frameIndex);
            if (!showVelocityVectors || !currentResults) {
                console.log('Skipping vectors - showVelocityVectors:', showVelocityVectors, 'currentResults:', !!currentResults);
                return;
            }
            
            // Remove old vector layer
            if (velocityVectorLayer) {
                map.removeLayer(velocityVectorLayer);
            }
            
            velocityVectorLayer = L.layerGroup().addTo(map);
            console.log('Created new velocity vector layer');
            
            var channelNames = ['nieuwe_waterweg', 'hartelkanaal', 'nieuwe_maas', 
                               'nieuwe_merwede', 'oude_maas', 'waal', 'haringvliet'];
            
            var t = frameIndex / 60 * 2 * Math.PI; // Phase for this frame
            console.log('Time phase:', t);
            
            var vectorCount = 0;
            
            channelNames.forEach(function(chName) {
                // Get data for the selected tidal component
                var channelData;
                if (currentTidalComponent === 'm4' && currentResults.m4_data && currentResults.m4_data[chName]) {
                    channelData = currentResults.m4_data[chName];
                } else if (currentTidalComponent === 'ratio') {
                    // For ratio, use M2 data (or could combine both)
                    channelData = currentResults.channels[chName];
                } else {
                    // M2 component (default)
                    channelData = currentResults.channels[chName];
                }
                
                if (!channelData) {
                    console.log('No data for channel:', chName);
                    return;
                }
                
                // Sample fewer points to avoid cluttering
                var skipPoints = Math.max(8, Math.floor(channelData.length / 8));
                
                // Create array of indices to iterate
                var indices = [];
                for (var idx = 0; idx < channelData.length; idx += skipPoints) {
                    indices.push(idx);
                }
                
                // Reverse indices for ALL channels due to reversed x-axis
                indices = indices.reverse();
                
                // Draw chevrons
                for (var idx_i = 0; idx_i < indices.length; idx_i++) {
                    var i = indices[idx_i];
                    var point = channelData[i];
                    
                    // Get velocity
                    var velAmp = point.velocity.amplitude;
                    var velPhase = point.velocity.phase;
                    
                    // Calculate instantaneous velocity
                    var uVal = velAmp * Math.cos(t - velPhase);
                    
                    // Skip if velocity is too small
                    if (Math.abs(uVal) < 0.08) continue;
                    
                    // Find corresponding lat/lon on the channel
                    var channelLayer = channelLayers.find(function(cl) {
                        return channelMapping[cl.name] === chName;
                    });
                    
                    if (!channelLayer) continue;
                    
                    var coords = channelLayer.data.coords;
                    if (!coords || coords.length === 0) continue;
                    
                    // Get position along channel
                    var pointIndex = Math.floor((i / channelData.length) * (coords.length - 1));
                    
                    // Reverse coordinate mapping for ALL channels
                    pointIndex = (coords.length - 1) - pointIndex;
                    pointIndex = Math.max(0, Math.min(pointIndex, coords.length - 1));
                    var latLng = coords[pointIndex];
                    
                    // Get adjacent points for line direction
                    var prevIndex = Math.max(0, pointIndex - 2);
                    var nextIndex = Math.min(coords.length - 1, pointIndex + 2);
                    
                    if (prevIndex === nextIndex) continue;
                    
                    var prevLatLng = coords[prevIndex];
                    var nextLatLng = coords[nextIndex];
                    
                    // Calculate line angle (direction of the channel)
                    var dx = nextLatLng[1] - prevLatLng[1];
                    var dy = nextLatLng[0] - prevLatLng[0];
                    var lineAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Determine chevron direction: > for flood, < for ebb
                    var chevron = uVal > 0 ? '‚ùØ' : '‚ùÆ';  // Unicode chevrons
                    var chevronColor = uVal > 0 ? '#3b82f6' : '#ef4444';
                    
                    // Size based on velocity
                    var fontSize = Math.min(Math.abs(uVal) * 25, 20);
                    fontSize = Math.max(fontSize, 14);
                    
                    var chevronIcon = L.divIcon({
                        className: 'velocity-chevron',
                        html: '<div style="font-size: ' + fontSize + 'px; color: ' + chevronColor + '; font-weight: bold; text-shadow: 0 0 3px rgba(0,0,0,0.8), 0 0 2px white; transform: rotate(' + lineAngle + 'deg); line-height: 1; font-family: Arial, sans-serif;">' + chevron + '</div>',
                        iconSize: [fontSize, fontSize],
                        iconAnchor: [fontSize / 2, fontSize / 2]
                    });
                    
                    var chevronMarker = L.marker([latLng[0], latLng[1]], {
                        icon: chevronIcon,
                        opacity: 0.95,
                        zIndexOffset: 1000
                    });
                    
                    velocityVectorLayer.addLayer(chevronMarker);
                }
            });
        }
        
        function updateVisualization(frameIndex) {
            if (!animationData || !channelLayers) return;
            
            // Select data based on current component
            var currentData, vmin, vmax, period_hours;
            if (currentTidalComponent === 'm4' && animationData_m4) {
                currentData = animationData_m4;
                vmin = animationData_m4.global_min;
                vmax = animationData_m4.global_max;
                period_hours = animationData_m4.period_hours;
            } else if (currentTidalComponent === 'ratio' && animationData_ratio) {
                currentData = animationData_ratio;
                vmin = animationData_ratio.global_min;
                vmax = animationData_ratio.global_max;
                period_hours = animationData.period_hours; // Use M2 period for display
            } else {
                currentData = animationData;
                vmin = animationData.global_min;
                vmax = animationData.global_max;
                period_hours = animationData.period_hours;
            }
            
            // Calculate current time in the tidal cycle
            var currentTime = (frameIndex / 60) * period_hours;
            var hours = Math.floor(currentTime);
            var minutes = Math.floor((currentTime - hours) * 60);
            document.getElementById('timeDisplay').textContent = 
                'Time: ' + hours + ':' + (minutes < 10 ? '0' : '') + minutes;
            
            // Calculate current phase in the cycle (0 to 2œÄ)
            var t = (frameIndex / 60) * 2 * Math.PI;
            
            // Remove old scatter markers
            scatterMarkers.forEach(function(marker) {
                map.removeLayer(marker);
            });
            scatterMarkers = [];
            
            // Hide original channel lines during animation (only show gradient)
            channelLayers.forEach(function(ch) {
                ch.layer.setStyle({opacity: 0, fillOpacity: 0});
            });
            
            // ALL channels need reversal (max amplitude should be at ocean/sea side)
            var channelsToReverse = ['nieuwe_waterweg', 'hartelkanaal', 'nieuwe_maas', 'nieuwe_merwede', 'oude_maas', 'haringvliet', 'waal'];
            
            // Create smooth gradient polylines for each channel
            channelLayers.forEach(function(ch) {
                var apiName = channelMapping[ch.name];
                var kmlKey = kmlMapping[ch.name];
                
                if (apiName && currentData.data[apiName]) {
                    var channelData = currentData.data[apiName];
                    var kmlCoords = kmlData[kmlKey]; // Get coordinates for this channel
                    
                    if (!kmlCoords) {
                        console.warn('No KML coords for:', ch.name, 'kmlKey:', kmlKey);
                        return;
                    }
                    
                    // Calculate water levels for all points
                    var waterLevels = [];
                    
                    if (currentTidalComponent === 'ratio') {
                        // For ratio, use the ratio value directly (no time variation)
                        channelData.points.forEach(function(point) {
                            waterLevels.push(point.ratio);
                        });
                    } else {
                        // For M2 and M4, calculate eta(t) = amplitude * cos(t - phase)
                        channelData.points.forEach(function(point) {
                            var eta_t = point.amplitude * Math.cos(t - point.phase);
                            waterLevels.push(eta_t);
                        });
                    }
                    
                    // Reverse water levels for ocean and middle channels (max at ocean side)
                    if (channelsToReverse.indexOf(apiName) !== -1) {
                        waterLevels.reverse();
                    }
                    
                    // Create colored line segments between consecutive points (smooth gradient)
                    for (var i = 0; i < waterLevels.length - 1; i++) {
                        var eta1 = waterLevels[i];
                        var eta2 = waterLevels[i + 1];
                        
                        // Average water level for this segment
                        var etaAvg = (eta1 + eta2) / 2;
                        
                        // Get coordinates for this segment from kmlCoords
                        var kmlIndex1 = Math.floor(i * kmlCoords.length / waterLevels.length);
                        var kmlIndex2 = Math.floor((i + 1) * kmlCoords.length / waterLevels.length);
                        
                        // Ensure indices are within bounds
                        kmlIndex1 = Math.min(kmlIndex1, kmlCoords.length - 1);
                        kmlIndex2 = Math.min(kmlIndex2, kmlCoords.length - 1);
                        
                        var coord1 = kmlCoords[kmlIndex1];
                        var coord2 = kmlCoords[kmlIndex2];
                        
                        // Normalize eta to 0-1 range using global min/max
                        var normalized = (etaAvg - vmin) / (vmax - vmin);
                        normalized = Math.max(0, Math.min(1, normalized));
                        
                        // Get color based on component type
                        var color;
                        if (currentTidalComponent === 'ratio') {
                            color = getViridisColor(normalized); // Yellow-Orange-Red for ratio
                        } else {
                            color = getRdBuColor_r(normalized); // RdBu_r for M2 and M4
                        }
                        
                        // Create polyline segment (smooth line between two points)
                        var segment = L.polyline([coord1, coord2], {
                            color: color,
                            weight: 8,  // Thick line for visibility
                            opacity: 1.0,
                            smoothFactor: 1
                        }).addTo(map);
                        
                        scatterMarkers.push(segment);
                    }
                }
            });
            
            // Draw velocity vectors if enabled
            // Velocity vectors removed
        }
        
        // RdBu_r colormap (Red-Blue reversed: high=red, low=blue)
        // Matches matplotlib's RdBu_r colormap
        function getRdBuColor_r(normalized) {
            // normalized: 0 = low (blue), 1 = high (red)
            // RdBu_r: Blue ‚Üí White ‚Üí Red
            
            var r, g, b;
            
            if (normalized < 0.5) {
                // Low values: Blue to White
                var t = normalized * 2; // 0 to 1
                r = Math.round(33 + (255 - 33) * t);
                g = Math.round(102 + (255 - 102) * t);
                b = Math.round(172 + (255 - 172) * t);
            } else {
                // High values: White to Red
                var t = (normalized - 0.5) * 2; // 0 to 1
                r = Math.round(255 + (178 - 255) * t);
                g = Math.round(255 + (24 - 255) * t);
                b = Math.round(255 + (43 - 255) * t);
            }
            
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }
        
        // Viridis-like colormap for M4/M2 ratio (White ‚Üí Yellow ‚Üí Orange ‚Üí Red)
        function getViridisColor(normalized) {
            // normalized: 0 = low ratio, 1 = high ratio
            var r, g, b;
            
            if (normalized < 0.33) {
                // Low: White to Yellow
                var t = normalized / 0.33;
                r = 255;
                g = 255;
                b = Math.round(255 * (1 - t));
            } else if (normalized < 0.67) {
                // Medium: Yellow to Orange
                var t = (normalized - 0.33) / 0.34;
                r = 255;
                g = Math.round(255 - (55 * t));
                b = 0;
            } else {
                // High: Orange to Red
                var t = (normalized - 0.67) / 0.33;
                r = Math.round(255 - (77 * t)); // 255 to 178
                g = Math.round(200 - (176 * t)); // 200 to 24
                b = Math.round(0 + (43 * t));    // 0 to 43
            }
            
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // Hook into displayResults to activate animation panel when results are available
        var originalDisplayResults = displayResults;
        displayResults = function(results) {
            // Call original function
            originalDisplayResults(results);
            
            // Activate animation if time series data is available
            if (results.time_series) {
                animationData = results.time_series;
                animationData_m4 = results.time_series_m4 || null;
                animationData_ratio = results.m4_m2_ratio || null;
                
                console.log('Animation data loaded:', animationData);
                console.log('M4 data loaded:', animationData_m4 ? 'Yes' : 'No');
                console.log('Ratio data loaded:', animationData_ratio ? 'Yes' : 'No');
                console.log('Channels in data:', Object.keys(animationData.data || {}));
                console.log('Sample channel data:', animationData.data ? animationData.data['nieuwe_waterweg'] : 'none');
                document.getElementById('animationPanel').classList.add('visible');
                resetAnimation();
            }
        };
        
        // Initialize map
        setTimeout(initMap, 100);
    </script>
</body>
</html>